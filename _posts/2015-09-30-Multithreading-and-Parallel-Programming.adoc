= Multithreading and Parallel Programming
:hp-tags: Java, Multithread

Multithreading enables multiple tasks in a program to be executed concurrently.
One of the powerful features of Java is its built-in support for _multithreading_—the concurrent running of multiple tasks within a program.

### Concept
A program may consist of many tasks that can run concurrently. 
A thread is the _flow of execution_, from beginning to end, of a task.

In _single-processor_ systems, the multiple threads share CPU time, known as _time sharing_, and the operating system is responsible for scheduling and allocating resources to them.


When your program executes as an application, the Java interpreter starts a thread for the *main* method. You can create additional threads to run concurrent tasks in the program. 

In Java, each task is an instance of the *Runnable* interface, also called a runnable object. A *thread* is essentially an object that facilitates the execution of a task.

### Creating Tasks and Threads
A task class must implement the *Runnable* interface. A task must be run from a thread.

Runnalble interface only contains a method, *public abstract _run_()*.
A task must be executed in a thread. The *Thread* class contains the constructors for creating threads and many useful methods for controlling threads. 
Invoke the *_start_*() method to tell the JVM that the thread is ready to run
The JVM will execute the task by invoking the task’s *_run_*() method.


### The Thread Class
The *Thread* class contains the constructors for creating threads for tasks and the
methods for controlling threads.

 Since the *_Thread_* class implements _Runnable_, you could define a class that extends Thread and implements the run method, and then create an object from the class and invoke its start method in a client program to start the thread
 
* *_yield_* () will release CPU time to other thread.
* *_sleep_* (long millis) method puts the thread to sleep for the specified time in mil- liseconds to allow other threads to execute. The method may throw a checked excetpion named *InterruptedException*

* *_join_* () method to force one thread to wait for another thread to finish
```java
Thread threa4 = new Thread(new Task());
for(int i = 0; i < 100; i++){
	if(i == 50) thread4.join();
    System.out.print(i);
}
```
In this case, number 50 to 99 will be printed *after thread 4 is finished*.
	


### Priority

Java assigns every thread a priority. By default, a thread inherits the priority of the thread that spawned it.

* *Priorities* are numbers ranging from 1 to 10. 
* The Thread class has the int constants *MIN_PRIORITY*, *NORM_PRIORITY*, and *MAX_PRIORITY*, representing 1, 5, and 10, respectively. 
* The priority of the *main* thread is *Thread.NORM_PRIORITY*.
* The JVM always picks the currently runnable thread with the *highest priority*.

You can increase or decrease the priority of any thread by using the *_setPriority_* method

you can get the thread’s priority by using the *_getPriority_* method.


A *lower- priority* thread can run only when no *higher-priority* threads are running. If all runnable threads have equal priorities, each is assigned an equal portion of the CPU time in a *circular queue*. This is called *_round-robin_* scheduling.